# ドメイン駆動設計入門 ボトムアップでわかる！ドメイン駆動設計の基本

* インターフェース層：コントローラー
* ユースケース層：アプリケーションサービス
* ドメイン層：エンティティ
* インフラストラクチャ層：リポジトリ（オブジェクトの永続化）

## 印象に残った点
* 値オブジェクトとDRY(Don't Repeat Yourself)原則
    * ユーザー名などをクラスにしてしまうことで、値に制限をかけるなどよくある話だなぁと思った。ど
        * どこまで厳密にやるかや、どこでその制限ルールを記述するとかの話。
            * ドメインに従って決めるとよさそうだと思った。
* エンティティについて
    * オブジェクトの同一性の話
    * 値オブジェクトかエンティティにするかは、そのオブジェクトにライフサイクルがあるかどうかで判断すればいい
        * 作成・変更・削除etc...
* ドメインサービスについて
    * エンティティにもたせるには不自然なメソッドなどを、ドメインサービスとして切り出そうという話。
        * リポジトリについては後章にて
* リポジトリについて
    * 永続化の部分をinterfaceにする。
    * ドメインを永続化するためのinterfaceなので、ドメインの特定の属性を引数として渡すようなinterfaceメソッドの定義は避けるべきである
        * Userドメインに対して、UpdateUserName(userId, userName)は悪い例。UpdateUser(User)の方がいい
* アプリケーションサービス
    * サービスの返り値として、ドメインを公開しないメリットを理解した。
    * DTO(Data Transfer Object)を使う利点を理解できた。
* 依存関係のコントロール
    * Service Locatorパターン、これは初めて知った。
        * 依存関係が外部から見えにくい、テストの維持が難しいなどの問題がある。
            * コンパイル時点では気づかないから。
    * IoC(Inversion of Control) Container
        * DI(Dependency Injection)の考え方を利用したやり方。DIが複数ヶ所に現れるのを防ぐことができる。
        * DIについては既知であった。
            * コンパイルの時点でバグに気づくことができる
* 8章ユーザーインターフェース
    * コントローラーについてのコラム。
    * インターフェース部分でコントローラーという言葉が使われる理由がわかった。
* ファクトリについて
    * 採番処理を例にした、ファクトリの例がわかりやすかった。
    * p213、エンティティを見たときにファクトリの存在を認識できない。
        * 同じパッケージにファクトリ置いておく
    * p218、ファクトリ部分をレポジトリに実装するかどうかの議論があった。
    * ポリモーフィズムの恩恵を利用する-ポリモーフィズムの恩恵を利用する-
* 10章 整合性とトランザクション
    * トランザクション機能を持たせるレイヤーについて
        * インフラレベル or サービスレベル（言語の機能を使う）
        * 設計方針が面白い
        * トランザクションスコープ
        * AOP aspect oriented programming
        * ユニットオブワーク パターン
            * エンティティへの変更履歴を保存しておき、最後にコミット処理を行う
            * 初めてしった。
            * リポジトリと連携しているパターンもある
    * DBアクセスなどトランザクション機能をどこに組み込むかという話
    * サービス層へインフラストラクチャ層の依存があると美しくないのでAOPやユニットオブワーク、インフラストラクチャ層に実装しようねってお話。
### 4章
* ドメイン貧血症モデル
    * ドメインサービスに定義しすぎる
    * ドメインサービスはできるだけ使わない
    * レポジトリへのアクセスがある場合はサービスにおく
### 11章 アプリケーションを1から組み立てる
* サンプルがのっている

### 12章
* 集約
    * オブジェクトの不変条件
    * サークルクラスがあったら、そのメンバーの数は10人以下のようなもの
* デメテルの法則 p273
    * 最小知識の原則
    * メソッドの呼び出しに関する条件

### 13章
* ファーストクラスコレクション
* 遅延実行
    * C#のサンプルが紹介されていた、Goのはあるのか。。。

### 14章
* レイヤードアーキテクチャ
* ヘキサゴナルアーキテクチャ
* クリーンアーキテクチャ


### 15章
* 本書で扱ったものだけで実装すると、軽量DDDとなるので気を付けること
* ユビキタス言語を使って実装することが大切である。ドメインエキスパートと開発者の言語の違い。以下は齟齬の例である。
  * ビジネスルールでは、「ユーザーを登録する」であるが、実装ではNewUserとしている
  * 「ユーザー名を変更する」を、UpdateUserNameと表現している
* コンテキストマップの重要性
  * 同じエンティティ（ユーザーなら、サービス利用用で定義しているユーザーと認証用で定義しているユーザー）を異なる場所に定義しているときに、それらの結びつきを表現しておいたほうがいい
    * サービス利用用のユーザーを変更したときに、認証用とで齟齬がおこる


## 所感
ファクトリを使うことでドメイン部分に複雑な処理を実装しなくていいことがわかった。また、ファクトリをインターフェースにすると、柔軟な設計ができるなと思った。  
ドメイン駆動設計に必要な考え方の基礎を理解することができた。  
「エンティティにおいて定義するメソッドが少なくなりすぎると軽量ドメインになってしまう」が、実装するときを考えると、エンティティ更新にはインフラストラクチャ層へのアクセスが不可避であり、軽量ドメインにならざるを得ないのではないかと思った。そもそもエンティティの一要素だけを更新するのような処理はドメイン駆動設計に反するのだろうか。本書の中ではSaveというメソッドがサービス層に定義されている例が散見された。
23行目にメモしていた（笑）

```
        * Userドメインに対して、UpdateUserName(userId, userName)は悪い例。UpdateUser(User)の方がいい
```

